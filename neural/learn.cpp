#include "everything.h"

using namespace std;

cv::Mat standardize(cv::Mat patches, float epsilon) {
    cv::Mat ret;
    patches.convertTo(ret, CV_32FC1);

    const int num_rows = patches.rows;

    printf("Standardizing all patches\n");
    // TODO does this need to be per-channel? I believe now.

#ifdef _USE_OPENMP
#pragma omp parallel for
#endif
    for(int i=0;i<num_rows;i++) {
        cv::Mat current = ret.row(i);
        cv::Mat temp2;
    
        cv::Scalar t = cv::mean(current);
        float mean = t[0];
        cv::pow(current-mean, 2, temp2);
        t = cv::sum(temp2)/(3*PATCH_SIZE*PATCH_SIZE);
        float var = t[0];
        float sd = sqrtf(var + epsilon);

        current = current - mean;
        current = current / sd;
    }

    return ret;
}

cv::Mat load_data(char* filename) {
    FILE *fp;
    int size;

    printf("Opening dataset: %s\n", filename);
    // Ensure the file can be loaded
    fp = fopen(filename, "rb");
    if(!fp) {
        printf("The file does not exist: %s\n", filename);
        return cv::Mat();
    }

    // Find the number of elements in this
    fseek(fp, 0, SEEK_END);
    size = ftell(fp);

    // Ensure we have an exact division
    if(size % (NUM_BYTES_PER_IMG+1) != 0) {
        printf("Non-integer number of elements in the given file. Exitting.\n");
        return cv::Mat();
    }

    //const int num_samples = size / (NUM_BYTES_PER_IMG + 1);
    const int num_samples = 100;
    const int size_minus_patch = (IMG_SIZE-PATCH_SIZE) * (IMG_SIZE-PATCH_SIZE);
    const int rcount = PATCH_SIZE * PATCH_SIZE * 3;
    cv::Mat data = cv::Mat::zeros(size_minus_patch*num_samples, rcount, CV_8UC1);
    printf("Number of images in dataset = %d\n", num_samples);


    // Rewind to the beginning to start reading actual data
    fseek(fp, 0, SEEK_SET);

    // Loop through the entire dataset
    int sample_count = 0;
    int sz[3] = {IMG_SIZE*PATCH_SIZE*PATCH_SIZE, IMG_SIZE-PATCH_SIZE, IMG_SIZE-PATCH_SIZE};
    cv::Mat patches = cv::Mat(3, sz, CV_32FC1, cv::Scalar(0));
    cv::Mat *scratch_channel = new cv::Mat[3];
    cv::Mat scratch;

    DECLARE_TIMING(file_reader);
    START_TIMING(file_reader);
    DECLARE_TIMING(individual_reader);

    int data_idx = 0;
    while(sample_count < num_samples) {
        START_TIMING(individual_reader);

        // Read in the data
        uchar label;
        uchar *img_data = new uchar[NUM_BYTES_PER_IMG];

        // Read label for this sample
        if(fread(&label, sizeof(uchar), 1, fp) != 1) {
            printf("Unable to read label for image %d\n", sample_count);
            return cv::Mat();
        }

        // Read pixel data
        if(fread(img_data, sizeof(uchar), NUM_BYTES_PER_IMG, fp) != NUM_BYTES_PER_IMG) {
            printf("Unable to read image data for image %d\n", sample_count);
            return cv::Mat();
        }

        // Generate a proper OpenCV matrix
        scratch_channel[0] = cv::Mat(IMG_SIZE, IMG_SIZE, CV_8UC1, img_data+0);
        scratch_channel[1] = cv::Mat(IMG_SIZE, IMG_SIZE, CV_8UC1, img_data+1024);
        scratch_channel[2] = cv::Mat(IMG_SIZE, IMG_SIZE, CV_8UC1, img_data+2048);
        cv::merge(scratch_channel, 3, scratch);

        // Calculate the individual patches
        int start_idx = data_idx;
        for(int y=0;y<IMG_SIZE-PATCH_SIZE;y++) {
            for(int x=0;x<IMG_SIZE-PATCH_SIZE;x++) {
                cv::Rect r(x, y, PATCH_SIZE, PATCH_SIZE);
                cv::Mat temp = scratch(r).clone();

                cv::Mat aux = data.row(data_idx);
                scratch(r).clone().reshape(1, 1).copyTo(aux);
                data_idx++;
            }
        }

        // Visualize the patches generated by the above code
        //cv::Mat visual = visualize_patches(scratch, data.rowRange(start_idx, data_idx));
        //cv::imshow("Visualizing patches", visual);
        //cv::waitKey(0);


        // Print progress
        if(sample_count%1000 == 0){
            printf("Sample count = %d\n", sample_count);
            printf("Reading %d took %d ms\n", sample_count, (int)GET_AVERAGE_TIMING(file_reader));
        }
        sample_count += 1;
        STOP_TIMING(individual_reader);
    }
    STOP_TIMING(file_reader);
    printf("It took %d ms to read the entire data file\n", (int)GET_TIMING(file_reader));

    fclose(fp);
    return shuffle_rows(data);
}

int main(int argc, char* argv[]) {
    const int rcount = PATCH_SIZE * PATCH_SIZE * 3;
    cv::Mat data = cv::Mat(rcount, SAMPLES, CV_32FC1);
    cv::Mat centroids = cv::Mat(rcount, CENTROIDS, CV_32FC1);
    cv::Mat zca_u = cv::Mat(rcount, rcount, CV_32FC1);
    cv::Mat zca_m = cv::Mat(rcount, 1, CV_32FC1);

    // Reading this from a file takes longer than executing this.
    cv::Mat patches = load_data("../data/data_batch_1.bin");
    patches = standardize(patches, STANDARDIZE_EPSILON);

    printf("Number of rows = %d\n", patches.rows);

    printf("Memory usage: %d KB\n", getMemValue());
    return 0;
}
